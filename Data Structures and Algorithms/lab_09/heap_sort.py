# Операция просеивания вниз (sift down) для элемента с индексом i в поддереве размером n,
# превращая его в максимальную кучу (max-heap).
# Сравнивает элемент с его левым и правым потомками,
# и если какой-либо из потомков больше текущего элемента, то происходит обмен значениями,
# и рекурсивно вызывается heapify для соответствующего поддерева.
def heapify(arr, n, i):
    largest = i  # Инициализируем наибольший элемент как корень
    left = 2 * i + 1  # Левый потомок
    right = 2 * i + 2  # Правый потомок

    # Если левый потомок существует и больше корня
    if left < n and arr[left] > arr[largest]:
        largest = left

    # Если правый потомок существует и больше корня
    if right < n and arr[right] > arr[largest]:
        largest = right

    # Если наибольший элемент не является корнем
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # Меняем местами элементы

        # Рекурсивно применяем heapify к поддереву
        heapify(arr, n, largest)


# Выполняет сортировку кучей для списка arr.
# Сначала она строит исходную max-кучу,
# проходя по элементам списка справа налево и вызывая heapify для каждого элемента.
# Затем она поочередно извлекает элементы из кучи,
# помещая максимальный элемент (корень кучи) в конец списка,
# а затем перестраивает кучу для оставшейся части списка.
# Это повторяется до тех пор, пока весь список не будет отсортирован.
def heap_sort(arr):
    n = len(arr)

    # Построение max-heap
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    # Извлечение элементов из кучи по одному
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # Меняем местами корень с последним элементом
        heapify(arr, i, 0)  # Перестраиваем кучу

    return arr


array = list(map(int, input().split()))
sorted_array = heap_sort(array)
print(sorted_array)